---
title: "Arson Wildfire data analysis workflow"
output: 
  md_document:
    variant: markdown_github
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "C:/Users/huyng/OneDrive - Toronto Metropolitan University/Huy Nguyen/PhD_EnSciMan_Ryerson_University/Arson project/Rproject/data")
knitr::opts_chunk$set(echo = FALSE)
```

## Documentation

This repo is accompanying the publication: "The Use of Computational Fingerprinting Techniques to Distinguish Sources of Accelerants Used in Wildfire Arson".

Users need to first install R with this [link](https://cran.r-project.org/mirrors.html) and Rstudio with this [link](https://posit.co/download/rstudio-desktop/).

This workflow ran on Windows 11 OS 11th Gen Intel(R) Core(TM) i7-11800H \@ 2.30GHz, 16 GB RAM;

THe RStudio version used in this demo is 2023.06.0+421 "Mountain Hydrangea" Release for Windows;

The R version used in this demo is 4.3.1

## Data processing

First, the following R packages are installed and loaded in the global environment along with in-house built functions to minimize repetitiveness in the code.

Details about these functions can be found in Data processing.R file in this repo.

```{r, echo = FALSE, message = FALSE, warning = FALSE}
# Loading Packages --------------------------------------------------------
library(ggplot2)
library(purrr)
library(vegan)
library(readxl)
library(tidyverse)
library(dplyr)
library(data.table)
library(writexl)
library(tidyr)
library(grid)
library(gridExtra)
library(stats)
library(FactoMineR)
library(factoextra)
library(compositions)
library(ggforce)
library(latticeExtra)
library(cluster)
library(umap)
library(plotly)
# library(NADA2)
# library(EnvStats)
# library(CensSpatial)
library(mice)

# Functions -------------------------------------------------------------------------------------------------------
# Notin function
`%notin%` <- Negate(`%in%`)
```


# STEP 1.1: Data import
```{r, echo = FALSE, message = FALSE, warning = FALSE}
target_comp <- read_xlsx(path = "Shortened ILR Compound List PF001A 07-06-2024.xlsx")
ASTM <- read_xlsx(path = "ILR Compound List 05-15-2024_Without DieselASTM.xlsx")
file_path <- "Gasolines_BOP_110424.xlsx"

dfs <- excel_sheets(file_path) %>%
  set_names() %>%
  map(~ read_excel(file_path, sheet = .x) %>% mutate(Sample_name = .x))

df_step1.1 <- bind_rows(dfs) %>%
  select(-c("RMF", "Area %")) %>%
  mutate(Octane_rating = ifelse(str_detect(Sample_name, "A"), "Gas_87", 
                                ifelse(str_detect(Sample_name, "B"), "Gas_89",
                                       ifelse(str_detect(Sample_name, "C"), "Gas_91", "Gas_94")))) %>%
  mutate(sampling_season = ifelse(str_detect(Sample_name, "b"), "blue",
                                  ifelse(str_detect(Sample_name, "p"), "purple", "orange"))) %>%
  mutate(gas_station = ifelse(str_detect(Sample_name, "F001"), "Station_1",
                              ifelse(str_detect(Sample_name, "F002"), "Station_2",
                                     ifelse(str_detect(Sample_name, "F003"), "Station_3",
                                            ifelse(str_detect(Sample_name, "F004"), "Station_4",
                                                   ifelse(str_detect(Sample_name, "F005"), "Station_5",
                                                          ifelse(str_detect(Sample_name, "F006"), "Station_6",
                                                                 ifelse(str_detect(Sample_name, "F007"), "Station_7",
                                                                        ifelse(str_detect(Sample_name, "F008"), "Station_8",
                                                                               ifelse(str_detect(Sample_name, "F009"), "Station_9", "Station_10")))))))))) 

# modify columns names
colnames(df_step1.1)[colnames(df_step1.1) == '<sup>1</sup>t<sub>R</sub>'] <- 'RT1'
colnames(df_step1.1)[colnames(df_step1.1) == '<sup>2</sup>t<sub>R</sub>'] <- 'RT2'
colnames(df_step1.1)[colnames(df_step1.1) == 'Major'] <- 'Ion1'
colnames(df_step1.1)[colnames(df_step1.1) == 'Qual'] <- 'Ion2'
```

# STEP 1.2: Filtering out column bleed, solvent and BTEX and MF = 0

```{r, echo = FALSE, message = FALSE, warning = FALSE}
filter_list <- c("^Carbon disulfide$", 
                "Cyclotrisiloxane..hexamethyl",
                "Cyclotetrasiloxane..octamethyl"
                # "^Benzene$",
                # "^Toluene$",
                # "^Ethylbenzene$",
                # "Xylene"
                )

# ^Carbon disulfide$ 75.890 - 75.959, 77.881 - 77.948

df_step1.2 <- copy(df_step1.1) %>%
  filter(MF > 0)

for (filter_comp in filter_list) {
  df_step1.2 <- df_step1.2 %>%
      filter(!grepl(filter_comp, Compound))
}

df_step2 <- df_step1.2 %>%
  filter(Area > 300000) %>%
  arrange(RT1, RT2)
```

#### Quality assurance: Histogram distribution of Peak values before data normalization
```{r class.source = 'fold-hide', echo = FALSE, message = FALSE, warning = FALSE}
ggplot(data = df_step2) +
  geom_histogram(aes(x= Area)) +
  facet_wrap(~Sample_name) +
  theme_minimal(base_size = 20) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5) 
        # strip.text = element_blank()
        )
```

### Plot benchmark distribution for aligning compounds later
```{r, echo = FALSE, message = FALSE, warning = FALSE}
bm_df <- df_step1.1 %>% 
  filter(grepl("Toluene-D8", Compound)) %>%
  filter(RT2 >= 3 & RT2 <= 5)

# Examining Retention time fluctuation of Toluene benchmark 
# RT1 hist plot 
hist(as.numeric(bm_df$RT1), breaks = 10, 
     xlab = "RT1", ylab ="", cex.axis = 2, cex.lab = 2, cex.main = 2,
     main = "Toluene")

# RT2 hist plot 
hist(as.numeric(bm_df$RT2), 
     xlab = "RT2", ylab ="", cex.axis = 2, cex.lab = 2, cex.main = 2,
     main = "Toluene")
```

# QUALITY CONTROL A OF STEP 1.2B: Plot Percentage coverage after removal of limit observation

```{r, echo = FALSE, message = FALSE, warning = FALSE}
plot_a <- list()
i <- 1
for (name in unique(df_step1.2$Sample_name)[50:70]) {
  coverage <- c()
  for (threshold in c(seq(from = 0, to = 300000, by = 50000))) {
    temp <- df_step1.2 %>%
      filter(Sample_name %in% name)
    df_filter_area <- temp %>%
      filter(Area > threshold)
    coverage <- c(coverage, sum(df_filter_area$Area)*100/sum(temp$Area))
  }
  df <- data.frame(thres = seq(from = 0, to = 300000, by = 50000), cover = coverage)
  plot_a[[i]] <- ggplot(data = df,
                      aes(x = thres, y = cover)) +
    geom_col() +
    theme(text = element_text(size = 10)) +
    geom_text(aes(label = round(cover, digits = 3)), color = "green", angle = 90, hjust = 1, size = 5) +
    scale_x_continuous(breaks = seq(from = 0, to = 300000, by = 50000),
                       # remove space between plotted data and xy-axes
                       expand = c(0,0)) +
    scale_y_continuous(breaks = seq(from = 0, to = 100, by = 25), 
                       # remove space between plotted data and xy-axes
                       expand = c(0,0)) +
    ggtitle(name) +
    labs(x = NULL, y = NULL) 
  i <- i + 1
}

y <- textGrob("Percentage coverage of remaining peaks after removal", rot = 90, gp = gpar(fontsize = 20))
x <- textGrob("Threshold of removal for limit observations", gp = gpar(fontsize = 20))

grid.arrange(grobs = plot_a, ncol = 5, 
             left = y,
             bottom = x)
```


# QUALITY CONTROL B OF STEP 1.2B: Plot number of peak remains after removal of limit observation

```{r, echo = FALSE, message = FALSE, warning = FALSE}
plot_b <- list()
i <- 1
for (name in unique(df_step1.2$Sample_name)[50:70]) {
  peak_remain <- c()
  for (threshold in c(seq(from = 0, to = 300000, by = 50000))) {
    temp <- df_step1.2 %>%
      filter(Sample_name %in% name)
    df_filter_area <- temp %>%
      filter(Area > threshold)
    peak_remain <- c(peak_remain, dim(df_filter_area)[1])
  }
  df <- data.frame(thres = seq(from = 0, to = 300000, by = 50000), remain = peak_remain)
  plot_b[[i]] <- ggplot(data = df,
                      aes(x = thres, y = remain)) +
    geom_col() +
    geom_text(aes(label = remain), color = "green", vjust = 1.2, size = 5) +
    scale_x_continuous(breaks = seq(from = 0, to = 300000, by = 50000), 
                       # remove space between plotted data and xy-axes
                       expand = c(0,0)) +
    ggtitle(name) +
    theme(axis.text.x = element_text(size = 20),
          axis.text.y = element_text(size = 20)) +
    labs(x = NULL, y = NULL) +
    theme_classic()
  i <- i + 1
}

y <- textGrob("Number of peak remains after removal of limit observation", rot = 90, gp = gpar(fontsize = 15))
x <- textGrob("Threshold of removal for limit observations", gp = gpar(fontsize = 15))

grid.arrange(grobs = plot_b, ncol = 5, 
             left = y,
             bottom = x)
```



## QUALITY CONTROL TO SELECT ALIGNMENT WINDOW: Confirming targeted compounds at each step of Data processing

(Update 22nd May 2024:) Using the target compound list, we will review 18 samples (6 samples across 3 seasons (p,b,o)) to determine how many samples have the target compounds. This data will help determine the effectiveness of the compression - similar to your microplastic table. 

We want to make sure that it works for all potential types of fuels. 

For the reporting table, there will be cases where the target compounds might not occur in some samples. The best alignment window will be the one that have highest  **"Proportion"** = samples have the target compounds/ 71 (total number of samples in the dataset).

Then, I pick the combination of Rt1 and Rt2 that results in the highest cumulative sum of the **"Proportion"** from all target compound by using **rowSums**.

```{r, echo = FALSE, message = FALSE, warning = FALSE}
target_comp <- readxl::read_xlsx(path = paste0(getwd(), "/Supplementary Materials.xlsx"), sheet = "List of target compounds")# "/Shortened ILR Compound List PF001A Fixed.xlsx"))

# For each target compounds,  Apply different alignment windows and record number of samples that have the =target compounds
combi <- tidyr::crossing(
  # RT1
  c(0.1 ,0.15, 0.2, 0.25, 0.3, 0.35, 0.4), 
  # RT2
  c(0.12,0.13,0.14,0.15, 0.16, 0.17, 0.18, 0.19, 0.2))

df <- data.frame(RT1_window=integer(), RT2_window=integer(), target=character(), proportion=integer())
  
for (i in 1:nrow(combi)) {
  for (j in 1:nrow(target_comp)) {
    # Catch all peaks in dataframe that falling into the window with target compounds as center of the window
    idx1 <- which((df_step2$Ion1 <= (target_comp[j,]$Ion1 + 0.1) & df_step2$Ion1 >= (target_comp[j,]$Ion1 - 0.1) & 
                   df_step2$Ion2 <= (target_comp[j,]$Ion2 + 0.1) & df_step2$Ion2 >= (target_comp[j,]$Ion2 - 0.1)) |
                    
                   (df_step2$Ion1 <= (target_comp[j,]$Ion2 + 0.1) & df_step2$Ion1 >= (target_comp[j,]$Ion2 - 0.1) &
                   df_step2$Ion2 <= (target_comp[j,]$Ion1 + 0.1) & df_step2$Ion2 >= (target_comp[j,]$Ion1 - 0.1)))
    
    temp <- df_step2[idx1,]
    minrt1 <- max(temp$RT1)
    maxrt1 <- min(temp$RT1)
    minrt2 <- max(temp$RT2)
    maxrt2 <- max(temp$RT2)
    
    
    idx2 <- which(temp$RT1 <= (target_comp[j,]$RT1 + as.numeric(combi[i,][1])) & 
                    temp$RT1 >= (target_comp[j,]$RT1 - as.numeric(combi[i,][1])) &
                    temp$RT2 <= (target_comp[j,]$RT2 + as.numeric(combi[i,][2])) & 
                    temp$RT2 >= (target_comp[j,]$RT2 - as.numeric(combi[i,][2])))
    
    df[nrow(df) + 1,] <- c(as.numeric(combi[i,][1]),
                           as.numeric(combi[i,][2]),
                           target_comp[j,]$Compound,
                           # paste0(length(unique(temp[idx2,]$Sample_name)), "/", 71))
                           100*(length(unique(temp[idx2,]$Sample_name)) / length(unique(temp$Sample_name))))
  }
}

summary_df <- df %>% pivot_wider(names_from = target, values_from = proportion)

# Which window have the highest proportion of samples that have the target compounds
summary_df[, 3:ncol(summary_df)] <- lapply(summary_df[, 3:ncol(summary_df)], as.numeric)
max_row <- summary_df[which.max(rowSums(summary_df[, 3:ncol(summary_df)])), ]
print(max_row)

# Adding the number of samples where the compounds were found with matching Ion1 and Ion2 to colnames of each compound
i <- 3
for (j in 1:nrow(target_comp)) {
  idx1 <- which((df_step2$Ion1 <= (target_comp[j,]$Ion1 + 0.1) & df_step2$Ion1 >= (target_comp[j,]$Ion1 - 0.1) & 
                   df_step2$Ion2 <= (target_comp[j,]$Ion2 + 0.1) & df_step2$Ion2 >= (target_comp[j,]$Ion2 - 0.1)) |
                  
                  (df_step2$Ion1 <= (target_comp[j,]$Ion2 + 0.1) & df_step2$Ion1 >= (target_comp[j,]$Ion2 - 0.1) &
                     df_step2$Ion2 <= (target_comp[j,]$Ion1 + 0.1) & df_step2$Ion2 >= (target_comp[j,]$Ion1 - 0.1)))
  
  temp <- df_step2[idx1,]
  idx2 <- which(temp$RT1 <= (target_comp[j,]$RT1 + as.numeric(max_row$RT1_window)) & 
                  temp$RT1 >= (target_comp[j,]$RT1 - as.numeric(max_row$RT1_window)) &
                  temp$RT2 <= (target_comp[j,]$RT2 + as.numeric(max_row$RT2_window)) & 
                  temp$RT2 >= (target_comp[j,]$RT2 - as.numeric(max_row$RT2_window)))
  
  colnames(summary_df)[i] <- paste0(target_comp[j,]$Compound, " (n = ", length(unique(temp$Sample_name)), ")")
  i <- i + 1 
}

writexl::write_xlsx(summary_df, path = paste0(getwd(), "/Testing combinations of Retention time window for compound alignment.xlsx"))
```


# QUALITY CONTROL: Examine the distribution of RT of target compounds after alignment with pF001A

```{r, echo = FALSE, message = FALSE, warning = FALSE}
target_comp <- read_xlsx("Shortened ILR Compound List PF001A 07-06-2024.xlsx")

# Get the column names from the existing data frame
column_names <- c( "Target compound", "RT", "Retention time of pF001A", "Min.", "1st Qu.", "Median",  "Mean", "3rd Qu.", "Max.", "Max. RT - Min. RT")
# Create an empty data frame with the same column names
summary_df <- data.frame(matrix(ncol = length(column_names), nrow = 0))
colnames(summary_df) <- column_names

summary_target_compounds <- list()
for (j in 1:nrow(target_comp)) {
    # First for each target compound, matching Major and minor ion 
    idx1 <- which((df_step2$Ion1 <= (target_comp[j,]$Ion1 + 0.2) & df_step2$Ion1 >= (target_comp[j,]$Ion1 - 0.2) & 
                   df_step2$Ion2 <= (target_comp[j,]$Ion2 + 0.2) & df_step2$Ion2 >= (target_comp[j,]$Ion2 - 0.2)) |
                    
                   (df_step2$Ion1 <= (target_comp[j,]$Ion2 + 0.2) & df_step2$Ion1 >= (target_comp[j,]$Ion2 - 0.2) &
                   df_step2$Ion2 <= (target_comp[j,]$Ion1 + 0.2) & df_step2$Ion2 >= (target_comp[j,]$Ion1 - 0.2)))
    
    temp <- df_step2[idx1,]
    
    # Then, for each target compound, matching within RT +- 0.1 wrt the pF001A retention time. 
    idx2 <- which(temp$RT1 <= (target_comp[j,]$RT1 + 0.1) & 
                  temp$RT1 >= (target_comp[j,]$RT1 - 0.1) &
                  temp$RT2 <= (target_comp[j,]$RT2 + 0.1) & 
                  temp$RT2 >= (target_comp[j,]$RT2 - 0.1))
    
    
    
    if (nrow(temp[idx2, ]) == 0) {
      summary_df[nrow(summary_df) + 1,] <- c(paste0(target_comp[j,]$Compound, " was not found with matching ions and within RT1/RT2 windows of 0.1 of pF001A"), NA, NA, NA, NA, NA, NA, NA, NA, NA)
    } else {
      
      # Make descriptive stats summary of RT1 of all peaks that was aligned to target compound in pF001A
      summary_df[nrow(summary_df) + 1,] <- c(target_comp[j,]$Compound,
                                             "RT1",
                                             as.numeric(target_comp[j,]$RT1),
                                             as.numeric(summary(as.numeric(temp[idx2,]$RT1))[[1]]),
                                             as.numeric(summary(as.numeric(temp[idx2,]$RT1))[[2]]),
                                             as.numeric(summary(as.numeric(temp[idx2,]$RT1))[[3]]),
                                             as.numeric(summary(as.numeric(temp[idx2,]$RT1))[[4]]),
                                             as.numeric(summary(as.numeric(temp[idx2,]$RT1))[[5]]),
                                             as.numeric(summary(as.numeric(temp[idx2,]$RT1))[[6]]),
                                             as.numeric(summary(as.numeric(temp[idx2,]$RT1))[[6]] - summary(as.numeric(temp[idx2,]$RT1))[[1]]))
      
      # Make descriptive stats summary of RT2 of all peaks that was aligned to target compound in pF001A
      summary_df[nrow(summary_df) + 1,] <- c(target_comp[j,]$Compound,
                                             "RT2",
                                             as.numeric(target_comp[j,]$RT2),
                                             as.numeric(summary(as.numeric(temp[idx2,]$RT2))[[1]]),
                                             as.numeric(summary(as.numeric(temp[idx2,]$RT2))[[2]]),
                                             as.numeric(summary(as.numeric(temp[idx2,]$RT2))[[3]]),
                                             as.numeric(summary(as.numeric(temp[idx2,]$RT2))[[4]]),
                                             as.numeric(summary(as.numeric(temp[idx2,]$RT2))[[5]]),
                                             as.numeric(summary(as.numeric(temp[idx2,]$RT2))[[6]]),
                                             as.numeric(summary(as.numeric(temp[idx2,]$RT2))[[6]] - summary(as.numeric(temp[idx2,]$RT2))[[1]]))
      # Make histogram of distribution of RT of these target compound
      # par(mfrow = c(1, 2))
      # hist(as.numeric(temp[idx2,]$RT1),
      #      xlab = "RT1", ylab ="", cex.axis = 2, cex.lab = 2, cex.main = 1,
      #      main = paste0("RT1 of ", target_comp[j,]$Compound, "\n with pF001A's RT1 = ", target_comp[j,]$RT1, " and RT1 window = 0.1"))
      # 
      # hist(as.numeric(temp[idx2,]$RT2), 
      #      xlab = "RT2", ylab ="", cex.axis = 2, cex.lab = 2, cex.main = 1,
      #      main = paste0("RT2 of ", target_comp[j,]$Compound, "\n in pF001A's RT2 = ", target_comp[j,]$RT2, " and RT2 window = 0.1"))
      
      # Reset the layout to default
      # par(mfrow = c(1, 1))
    }
}

View(summary_df)

writexl::write_xlsx(summary_df, path = paste0(getwd(), "/summary of target compounds matching by major and minor ions and rt1_rt2 of (0.1)_", format(Sys.Date(), "%d-%m-%y"), ".xlsx"))
```


# Make a table for the compounds that was not found in all samples, give the names of the samples where these target compounds are missing
***If the compound can be found in all samples then plot it with x-axis as 71 samples sorted from gas_station 1 to 10, the legend is the sampling season***

(Update 31 May 2024): For the bar plot of target compounds, if the compounds were not presented in a station -> it will have zeros values instead of NA -> it is show in the plot that the compound was not there in certain gas stations.

```{r, echo = FALSE, message = FALSE, warning = FALSE}
summary_df2 <- data.frame(target=character(), samples_that_missing_target_compound=character())

df_step2 <- df_step2 %>% 
  mutate(gas_station = factor(gas_station, levels = unique(df_step2$gas_station)))

for (j in 1:nrow(target_comp)) {
  idx1 <- which((df_step2$Ion1 <= (target_comp[j,]$Ion1 + 0.1) & df_step2$Ion1 >= (target_comp[j,]$Ion1 - 0.1) & 
                   df_step2$Ion2 <= (target_comp[j,]$Ion2 + 0.1) & df_step2$Ion2 >= (target_comp[j,]$Ion2 - 0.1)) |
                  
                  (df_step2$Ion1 <= (target_comp[j,]$Ion2 + 0.1) & df_step2$Ion1 >= (target_comp[j,]$Ion2 - 0.1) &
                     df_step2$Ion2 <= (target_comp[j,]$Ion1 + 0.1) & df_step2$Ion2 >= (target_comp[j,]$Ion1 - 0.1)))
  
  temp <- df_step2[idx1,]
  idx2 <- which(temp$RT1 <= (target_comp[j,]$RT1 + as.numeric(max_row$RT1_window)) & 
                  temp$RT1 >= (target_comp[j,]$RT1 - as.numeric(max_row$RT1_window)) &
                  temp$RT2 <= (target_comp[j,]$RT2 + as.numeric(max_row$RT2_window)) & 
                  temp$RT2 >= (target_comp[j,]$RT2 - as.numeric(max_row$RT2_window)))
  
  if (length(unique(temp[idx2,]$Sample_name)) < 71) {
    summary_df2[nrow(summary_df2) + 1,] <- c(target_comp[j,]$Compound,
                                             paste(setdiff(unique(df_step2$Sample_name), 
                                                           unique(temp[idx2,]$Sample_name)), 
                                                   collapse = ", "))
    
    # Artificial add in the missing samples and put the Area of those sample to be 0
    empty_df <- temp[idx2,] %>% select(Area, Sample_name, Octane_rating, sampling_season, gas_station) %>% slice(0)
    new_rows <- data.frame(
      Area = rep(0, length(setdiff(unique(df_step2$Sample_name), 
                                   unique(temp[idx2,]$Sample_name)))),
      Sample_name = setdiff(unique(df_step2$Sample_name), 
                     unique(temp[idx2,]$Sample_name)),
      Octane_rating = rep(NA, length(setdiff(unique(df_step2$Sample_name), 
                                            unique(temp[idx2,]$Sample_name)))),
      sampling_season = rep(NA, length(setdiff(unique(df_step2$Sample_name), 
                                              unique(temp[idx2,]$Sample_name)))),
      gas_station = rep(NA, length(setdiff(unique(df_step2$Sample_name), 
                                          unique(temp[idx2,]$Sample_name))))
    )
    temp2 <- bind_rows(empty_df, new_rows) %>%
      mutate(Octane_rating = ifelse(str_detect(Sample_name, "A"), "Gas_87", 
                                    ifelse(str_detect(Sample_name, "B"), "Gas_89",
                                           ifelse(str_detect(Sample_name, "C"), "Gas_91", "Gas_94")))) %>%
      mutate(sampling_season = ifelse(str_detect(Sample_name, "b"), "blue",
                                      ifelse(str_detect(Sample_name, "p"), "purple", "orange"))) %>%
      mutate(gas_station = ifelse(str_detect(Sample_name, "F001"), "Station_1",
                                  ifelse(str_detect(Sample_name, "F002"), "Station_2",
                                         ifelse(str_detect(Sample_name, "F003"), "Station_3",
                                                ifelse(str_detect(Sample_name, "F004"), "Station_4",
                                                       ifelse(str_detect(Sample_name, "F005"), "Station_5",
                                                              ifelse(str_detect(Sample_name, "F006"), "Station_6",
                                                                     ifelse(str_detect(Sample_name, "F007"), "Station_7",
                                                                            ifelse(str_detect(Sample_name, "F008"), "Station_8",
                                                                                   ifelse(str_detect(Sample_name, "F009"), "Station_9", "Station_10")))))))))) %>% 
      mutate(new_sample_name = paste0(Sample_name, "_", gas_station, "_", Octane_rating))
    
    plotdata <- bind_rows(temp2, temp[idx2,] %>% 
                            select(Area, Sample_name, Octane_rating, sampling_season, gas_station) %>%
                            mutate(new_sample_name = paste0(Sample_name, "_", gas_station, "_", Octane_rating)))
    
    print(ggplot(data = plotdata, aes(x = new_sample_name , y = Area, fill = sampling_season)) + 
            geom_bar(stat = "identity") +
            labs(title = target_comp[j,]$Compound, 
                 x = "Samples", y = "Peak Area",
                 fill = "") +
            theme_minimal(base_size = 15) +
            theme(axis.text.x = element_text(angle = 90, hjust =0.5, vjust = 0.25, color = "black", face = "bold"), 
                  plot.title = element_text(size = 25),
                  axis.ticks.length.x = unit(0, "cm"),
                  panel.grid.minor.x = element_blank(),
                  panel.grid.minor.y = element_blank()) + 
            scale_y_continuous(expand = c(0,0)))
  } else {
    temp2 <- temp[idx2,] %>%
      mutate(new_sample_name = paste0(Sample_name, "_", gas_station, "_", Octane_rating))
    print(ggplot(data = temp2, aes(x = new_sample_name , y = Area, fill = sampling_season)) + 
            geom_bar(stat = "identity") +
            labs(title = target_comp[j,]$Compound, 
                 x = "Samples", y = "Peak Area",
                 fill = "") +
            theme_minimal(base_size = 15) +
            theme(axis.text.x = element_text(angle = 90, hjust =0.5, vjust = 0.25, color = "black", face = "bold"), 
                  plot.title = element_text(size = 25),
                  axis.ticks.length.x = unit(0, "cm"),
                  panel.grid.minor.x = element_blank(),
                  panel.grid.minor.y = element_blank()) + 
            scale_y_continuous(expand = c(0,0)))
  }
}

writexl::write_xlsx(summary_df2, path = paste0(getwd(), "/Samples where target compounds are missing.xlsx"))
```

# STEP 2: Grouping compounds based on RT1, RT2, Ion1, Ion2

```{r, echo = FALSE, message = FALSE, warning = FALSE}
# Define tolerances
tolerances <- list(RT1 = 0.1, RT2 = 0.1, Ion1 = 0.5, Ion2 = 0.5)

# Use pF001A as a base
df_all <- df_step2 %>% 
  filter(Sample_name %in% "pF001A") %>% 
  filter(`Signal to Noise` > 10)
df_all$Feature <- 1:nrow(df_all)

# Loop through the samples apart from pF001A
for (sample in setdiff(unique(df_step2$Sample_name), c("pF001A", "bF001A", "bF007B"))) {
  # print(sample)
  df <- df_step2 %>% 
    filter(Sample_name %in% sample) %>% 
    filter(`Signal to Noise` > 10)
  df$Feature <- NA
  
  # Go through each row
  for (i in 1:nrow(df)) {
    row <- df[i, ]
    mask <- (
      abs(df_all$RT1 - row$RT1) <= tolerances$RT1 &
      abs(df_all$RT2 - row$RT2) <= tolerances$RT2 & 
      abs(df_all$Ion1 - row$Ion1) <= tolerances$Ion1 &
      abs(df_all$Ion2 - row$Ion2) <= tolerances$Ion2
    )
    
    idx <- which(mask)
    # If there is a match between a peak and the existing peak list, then assign the same Feature number to that peak 
    if (any(mask)) {
      row$Feature <- unique(df_all[idx, ]$Feature)[1]
    } else { # If not a match, then create new identity for the new Feature 
      row$Feature <- max(df_all$Feature) + 1
    }
    
    # adding the peak that have matchs in df_all
    df_all <- bind_rows(df_all, row)
  }
}

df_all <- df_all %>%
  # remove all peak with RT1 > 36 (which does not belong Gasoline)
  filter(RT1 < 30)

# Create metadata for next data analysis
metadata <- df_all %>%
  dplyr::select(
    Feature,
    Sample_name,
    Area) %>%
  group_by(Feature,
           Sample_name) %>%
  dplyr::summarise(across(Area, base::mean)) %>%
  tidyr::pivot_wider(names_from = Sample_name,
                     values_from = Area) 

#### Adding avg RT and Ions to the master df for Gwen
mean_rt1 <- c()
mean_rt2 <- c()
mean_ion1 <- c()
mean_ion2 <- c()

for (i in 1:nrow(metadata)) {
  mean_rt1 <- c(mean_rt1, mean(df_all[which(df_all$Feature  %in% metadata[i, ]$Feature),]$RT1))
  mean_rt2 <- c(mean_rt2, mean(df_all[which(df_all$Feature  %in% metadata[i, ]$Feature),]$RT2))
  mean_ion1 <- c(mean_ion1, mean(df_all[which(df_all$Feature  %in% metadata[i, ]$Feature),]$Ion1))
  mean_ion2 <- c(mean_ion2, mean(df_all[which(df_all$Feature  %in% metadata[i, ]$Feature),]$Ion2))
}

metadata$RT1 <- mean_rt1
metadata$RT2 <- mean_rt2
metadata$Ion1 <- mean_ion1
metadata$Ion2 <- mean_ion2

metadata <- metadata %>% relocate(RT1, RT2, Ion1, Ion2, .after = 1)

#### Adding Chemical groups of  to the master df for Gwen
chemical_group <- c()

for (i in 1:nrow(metadata)) {
  idx <- which(abs(metadata[i,]$Ion1 -target_comp$Ion1) <=  0.5 & 
                 abs(metadata[i,]$Ion2 -target_comp$Ion2) <=  0.5 )
  if (identical(idx, integer(0))) {
    chemical_group <- c(chemical_group, "unknown")
    next
  } else {
    chemical_group <- c(chemical_group, unique(target_comp[idx,]$Group))
  }
}

metadata$Chemical_group <- chemical_group

metadata <- metadata %>% relocate(Chemical_group, .after = 1)

# Export masterlist and metadata for Gwen
# writexl::write_xlsx(df_all, path = paste0("MasterList_", format(Sys.Date(), format = "%d-%b-%Y"), ".xlsx"))
# writexl::write_xlsx(metadata_export, path = paste0("PeakTable_", format(Sys.Date(), format = "%d-%b-%Y"), ".xlsx"))
```

(Update 22nd May 2024:) The alignment is based on pF001A, align all peaks in data set with each peak of pF001A.

### (Update 20th June 2024): SELECT COMPOUNDS THAT belongs to the target compound’s Chemical Group ----------------
```{r, echo = FALSE, message = FALSE, warning = FALSE}
metadata <- metadata %>% 
  # filter(., Chemical_group %notin% "unknown") %>%
  arrange(Chemical_group, RT1, RT2)
```

### Combine data from chemical groups
```{r, echo = FALSE, message = FALSE, warning = FALSE}
# new_metadata <- metadata %>%
#   group_by(Chemical_group) %>%
#   summarize(across(everything(), sum, na.rm = TRUE))
```


### REMOVE COMPOUNDS THAT HAVE < x% MISSING VALUES ----------------
```{r, echo = FALSE, message = FALSE, warning = FALSE}
less_na <- c()
for (row in 1:nrow(metadata)) {
  # Filter our compounds that have more than x % NA values
  if (sum(is.na(metadata[row,7:ncol(metadata)]))/dim(metadata[,7:ncol(metadata)])[2] <= 0.9) {
    less_na <- c(less_na, row)
  }
}

if (!is.null(less_na)) {
  metadata_na_remove <- metadata[less_na,]
}
```

### Subset compound that only appear in 1 gas station
```{r class.source = 'fold-hide', echo = FALSE, message = FALSE, warning = FALSE}
unique_comp <- c()

for (feature in unique(df_all$Feature)) {
  if (length(unique(df_all[which(df_all$Feature == feature),]$Sample_name)) < 2) {
    unique_comp <- c(unique_comp, feature)
  }
}

# A). dataset with non-unique compounds
new_df <- metadata %>% filter(Feature %notin% unique_comp)

# B). dataset with only unique compounds
unique_df <- metadata %>% filter(Feature %in% unique_comp)
```

## Investigate data distribution of compounds with high mean and high/low std

```{r, echo = FALSE, message = FALSE, warning = FALSE}
# Investigate data distribution for removal of compounds with high mean and low variance
# hist((shared_comp_alignment %>%
#   filter(Area < 10000000))$Area)

summary_table <- new_df %>% # metadata_na_remove %>% 
  ungroup() %>%
  rowwise() %>%
  mutate(mean_area = mean(c_across(7:ncol(.)), na.rm = TRUE),
         sd_area = sd(c_across(7:ncol(.)), na.rm = TRUE)) %>%
  ungroup() %>% 
  relocate(mean_area, sd_area, .before = 1)

View(summary_table %>% arrange(desc(mean_area), desc(sd_area)))

highmean_highstd <- list()
i <- 1
for (num_feature in c(25,50,100,200)) {
  # Adding back the labelling to metadata
  highmean_highstd[[i]] <- as.data.frame(t((summary_table %>% arrange(desc(mean_area), desc(sd_area)))[1:num_feature,] %>%  #
                                # filter(Feature %in% unique(highmean_highstd$Feature)) %>% # Select compounds with high peak area's mean and std.
                                select(-c("Chemical_group", "RT1", 
                                          "RT2", "Ion1", "Ion2", "mean_area", "sd_area")) %>% 
                                column_to_rownames(., var = "Feature"))) %>% 
    rownames_to_column(., var="Sample_name") %>% 
    mutate(Octane_rating = ifelse(str_detect(Sample_name, "A"), "Gas 87", 
                                  ifelse(str_detect(Sample_name, "B"), "Gas 89",
                                         ifelse(str_detect(Sample_name, "C"), "Gas 91", "Gas 94")))) %>%
    mutate(sampling_season = ifelse(str_detect(Sample_name, "b"), "blue",
                                    ifelse(str_detect(Sample_name, "p"), "purple", "orange"))) %>%
    mutate(gas_station = ifelse(str_detect(Sample_name, "F001"), "Station 1",
                                ifelse(str_detect(Sample_name, "F002"), "Station 2",
                                       ifelse(str_detect(Sample_name, "F003"), "Station 3",
                                              ifelse(str_detect(Sample_name, "F004"), "Station 4",
                                                     ifelse(str_detect(Sample_name, "F005"), "Station 5",
                                                            ifelse(str_detect(Sample_name, "F006"), "Station 6",
                                                                   ifelse(str_detect(Sample_name, "F007"), "Station 7",
                                                                          ifelse(str_detect(Sample_name, "F008"), "Station 8",
                                                                                 ifelse(str_detect(Sample_name, "F009"), "Station 9", "Station 10")))))))))) %>% 
    # Add info on Suppliers
    mutate(supplier = ifelse(str_detect(Sample_name, "F001"), "Miscellanous",
                             ifelse(str_detect(Sample_name, "F002"), "Miscellanous",
                                    ifelse(str_detect(Sample_name, "F003"), "Shell",
                                           ifelse(str_detect(Sample_name, "F004"), "Cenovus",
                                                  ifelse(str_detect(Sample_name, "F005"), "Miscellanous",
                                                         ifelse(str_detect(Sample_name, "F006"), "Suncor",
                                                                ifelse(str_detect(Sample_name, "F007"), "Imperial",
                                                                       ifelse(str_detect(Sample_name, "F008"), "Burnaby",
                                                                              ifelse(str_detect(Sample_name, "F009"), "Imperial", "unknown")))))))))) %>% 
    relocate(Octane_rating, sampling_season, gas_station, supplier, .after = 1)
  i <- i + 1
}

# ggplot(data = plotdf %>% mutate(Feature = factor(Feature, levels = unique(Feature))), aes(x=Feature, y = mean_area)) +
#   geom_bar(stat = 'identity', position = position_dodge(width = 0.9)) +
#   geom_errorbar(aes(ymin = mean_area - sd_area,
#                     ymax = mean_area + sd_area, colour = "red")) +
#   ggtitle("Rank 1:100") +
#   theme_classic(base_size = 15) +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
```

# STEP 4: Missing value imputation
(Update 21 April 2024:) After remove compounds appear in only one sample and compounds that have >90% Missing values -> plot histogram of distribution -> most of compounds are < 2e+06 => try filter all peaks that is >= 2e+06

## Option 1: 0.001
(UPDATE 17th Jul 2024: Meeting with Bonnie Hamilton and Eric Fries)
```{r, echo = FALSE, message = FALSE, warning = FALSE}
df_0.001 <- list()
for (i in 1:length(highmean_highstd)) {
  df_0.001[[i]] <- highmean_highstd[[i]]
  for (r in 1:nrow(df_0.001[[i]])) {
    df_0.001[[i]][r, which(base::is.na(df_0.001[[i]][r,]))] <- 0.001
  }
}
```

## Option 2: LOD 
LOD = go through each row of the df and replacing missing values = the lowest values of each sample * 3

```{r , echo=FALSE, warning = FALSE, message=FALSE}
df_lod <- list()
for (i in 1:length(highmean_highstd)) {
  df_lod[[i]] <- highmean_highstd[[i]]
  for (r in 1:nrow(df_lod[[i]])) { 
    df_lod[[i]][r, 6:ncol(df_lod[[i]])][,which(base::is.na(df_lod[[i]][r, 6:ncol(df_lod[[i]])]))] <- 3*min(df_lod[[i]][r, 6:ncol(df_lod[[i]])][,which(!base::is.na(df_lod[[i]][r, 6:ncol(df_lod[[i]])]))])
  } 
}
```

## Option 3: Randomized values drawn from uniform distribution of the two global minimum values
```{r , echo=FALSE, warning = FALSE, message=FALSE}
min_df <- list()
for (i in 1:length(highmean_highstd)) {
  min_df[[i]] <- highmean_highstd[[i]]
  for (r in 1:nrow(min_df[[i]])) { 
    min_df[[i]][r, which(base::is.na(min_df[[i]][r,]))] <- as.list(runif(length(which(is.na(min_df[[i]][r,]))),
                                                                         min = 0,
                                                                         max = sort(df_all$Area)[1]))
  }
}
```

## Option 4: with mice

'cart', 'rf', 'sample', "2l.lmer" is quite robust when the matrix has linearly dependent columns or is near-singular due to multicollinearity or insufficient variation in the data. 
'rf' still resulted in missing values after complete(imp) -> consider not using it
```{r, echo = FALSE, message = FALSE, warning = FALSE}
mice_df <- list()
for (i in 1:length(highmean_highstd)) {
  mice_df[[i]] <- highmean_highstd[[i]][,-c(1,2,3,4,5)]
  
  colnames(mice_df[[i]]) <- paste0("Comp_", colnames(mice_df[[i]]))
  imp <- mice(mice_df[[i]], method = "cart", ridge = 0.0001, threshold=1.1)
  imp_df <- complete(imp)
  mice_df[[i]]<- cbind(highmean_highstd[[i]][,c(1,2,3,4,5)], imp_df) 
}

for (i in 1:length(mice_df)) {
  temp <-  mice_df[[i]][,-c(1,2,3,4,5)]
  for (col in 1:ncol(temp)) {
    colnames(temp)[col] <- unlist(strsplit(colnames(temp)[col], split = "_"))[2]
  }
  mice_df[[i]]<- cbind(highmean_highstd[[i]][,c(1,2,3,4,5)], temp) 
}
```


# STEP 4: Data Normalization

### Percentage-based normalization
```{r, echo = FALSE, message = FALSE, warning = FALSE}
input <- df_0.001
percentage_normalized <- list()

for (i in 1:length(input)) {
  percentage_normalized[[i]] <- as.data.frame(t(apply(input[[i]][, 6:ncol(input[[i]])],
                                                      MARGIN = 1, 
                                                      function(row) {row/sum(row, na.rm = TRUE)}))) 
  
  percentage_normalized[[i]] <- percentage_normalized[[i]] %>% 
    mutate(Octane_rating = input[[i]]$Octane_rating) %>%
    mutate(sampling_season = input[[i]]$sampling_season) %>%
    mutate(gas_station = input[[i]]$gas_station) %>%
    mutate(Sample_name = input[[i]]$Sample_name) %>%
    mutate(supplier = input[[i]]$supplier) %>%
    relocate(Octane_rating, sampling_season, gas_station, Sample_name, supplier, .before = 1)
}
```

### Log normalization
```{r, echo = FALSE, message = FALSE, warning = FALSE}
input <- mice_df
log_normalized <- list()

for (i in 1:length(input)) {
  log_normalized[[i]] <- as.data.frame(t(apply(input[[i]][, 6:ncol(input[[i]])], 
                                               MARGIN = 1, function(x) log(x))))
  
  log_normalized[[i]] <- log_normalized[[i]] %>% 
    mutate(Octane_rating = input[[i]]$Octane_rating) %>%
    mutate(sampling_season = input[[i]]$sampling_season) %>%
    mutate(gas_station = input[[i]]$gas_station) %>%
    mutate(Sample_name = input[[i]]$Sample_name) %>%
    mutate(supplier = input[[i]]$supplier) %>%
    relocate(supplier, Octane_rating, sampling_season, gas_station, Sample_name, .before = 1)
}
```


# Exploratory Data Analysis

# Stacked bar plot of each suppliers
```{r, echo = FALSE, message = FALSE, warning = FALSE}
df <- percentage_normalized[[4]] %>% # df_step3  %>%
  pivot_longer(cols = 6:ncol(.), names_to = "Feature", values_to = "Area") %>%
  filter(Feature %in% unique(t_test_res$Feature))

# Obtain chemical group for each feature 
# Create a named vector for fast lookup
compound_name <- setNames(t_test_res$compound_name, t_test_res$Feature)

# Use the vector to directly map the Chemical_group to the Feature in df
df$compound_name <- compound_name[df$Feature]

df$Sample_name <- factor(df$Sample_name, levels = sort(unique(df$Sample_name)))

df <- df %>% 
  filter(gas_station %in% c("Station 3", "Station 4", "Station 6", "Station 7")) %>%
  filter(supplier %notin% "unknown") %>% 
  filter(Chemical_group %notin% "unknown")



plot_list <- list()
i <- 1
for (focus_supplier in unique(df$supplier)) {
  plot_df <- df %>%
    filter(supplier %in% focus_supplier)
  
  plot_list[[i]] <- ggplot(data = plot_df, aes(x = Sample_name, y = Area, fill = Chemical_group)) +
    geom_bar(stat = "identity") +
    labs(title = focus_supplier,
         x = "", 
         y = "") +
    theme_minimal(base_size = 18) +
    theme(axis.text.x = element_text(angle = 90, hjust =0.5, vjust = 0.25,
                                     # size = 18,
                                     face = "bold"), 
          axis.ticks.length.x = unit(0, "cm"),
          # legend.text = element_text(size = 18),
          # legend.title = element_text(size = 18),
          # axis.title.y = element_text(size = 15),
          legend.position = "hidden",
          plot.title = element_text(hjust = 0.5),
          panel.grid.minor.x = element_blank(),
          panel.grid.minor.y = element_blank(),
          panel.grid.major.x = element_blank(),
          panel.grid.major.y = element_blank()
          ) + 
    scale_y_continuous(expand = c(0,0))
  i <- i + 1
}

legend <- cowplot::get_legend(ggplot(data = plot_df, aes(x = Sample_name, y = Area, fill = Chemical_group)) +
                                geom_bar(stat = "identity") +
                                facet_wrap(~supplier) +
                                labs(fill = "Chemical Groups") +
                                theme_minimal(base_size = 20) +
                                theme(legend.text = element_text(size = 18),
                                      legend.title = element_text(size = 20),
                                      axis.title.y = element_text(size = 20),
                                      legend.position = "right"))

y <- textGrob("Peak Area", rot = 90, gp = gpar(fontsize = 20))
x <- textGrob("Samples", gp = gpar(fontsize = 20))

grid.arrange(grobs = plot_list, ncol = 3, nrow = 2, right = legend, left = y, bottom = x)
```

# Stacked bar plot of sampling seasons
```{r, echo = FALSE, message = FALSE, warning = FALSE}
df <- df_step3  %>%
  pivot_longer(cols = 6:ncol(.), names_to = "Feature", values_to = "Area")

# Obtain chemical group for each feature 
# Create a named vector for fast lookup
chemical_groups <- setNames(metadata$Chemical_group, metadata$Feature)

# Use the vector to directly map the Chemical_group to the Feature in df
df$Chemical_group <- chemical_groups[df$Feature]

df$Sample_name <- factor(df$Sample_name, levels = sort(unique(df$Sample_name)))
df$Octane_rating <- factor(df$Octane_rating, levels = sort(unique(df$Octane_rating)))
df$sampling_season <- factor(df$sampling_season, levels = sort(unique(df$sampling_season)))
df <- df %>% filter(supplier %notin% "unknown") %>% filter(Chemical_group %notin% "unknown")

plot_list <- list()
i <- 1
for (focus_season in levels(df$sampling_season)) {
  for (focus_octane in levels(df$Octane_rating)) {
    plot_df <- df %>%
      filter(sampling_season %in% focus_season) %>%
      filter(Octane_rating %in% focus_octane)
    
    plot_list[[i]] <- ggplot(data = plot_df, aes(x = Sample_name, y = Area, fill = Chemical_group)) +
      geom_bar(stat = "identity") +
      labs(title = paste0(focus_season, " - ", focus_octane),
           x = "", 
           y = "") +
      theme_minimal(base_size = 18) +
      theme(axis.text.x = element_text(angle = 90, hjust =0.5, vjust = 0.25, size = 15,
                                       face = "bold"), 
            axis.ticks.length.x = unit(0, "cm"),
            legend.text = element_text(size = 18),
            legend.title = element_text(size = 18),
            axis.title.y = element_text(size = 15),
            legend.position = "hidden",
            plot.title = element_text(hjust = 0.5),
            panel.grid.minor.x = element_blank(),
            panel.grid.minor.y = element_blank(),
            panel.grid.major.x = element_blank(),
            panel.grid.major.y = element_blank()
      ) + 
      scale_y_continuous(expand = c(0,0))
    i <- i + 1 
  }
}

legend <- cowplot::get_legend(ggplot(data = plot_df, aes(x = Sample_name, y = Area, fill = Chemical_group)) +
                                geom_bar(stat = "identity") +
                                labs(fill = "Chemical Groups") +
                                theme_minimal(base_size = 20) +
                                theme(legend.text = element_text(size = 18),
                                      legend.title = element_text(size = 20),
                                      axis.title.y = element_text(size = 20),
                                      legend.position = "right"))

y <- textGrob("Peak Area", rot = 90, gp = gpar(fontsize = 20))
x <- textGrob("Samples", gp = gpar(fontsize = 20))

grid.arrange(grobs = plot_list, ncol = 4, right = legend, left = y, bottom = x)
```


# Feature selection
```{r, echo = FALSE, message = FALSE, warning = FALSE}
library(MASS)  # For mvrnorm
library(stats)  # For ANOVA

# Function to generate confidence ellipses
confidence_ellipse <- function(mean, cov, conf.level = 0.95) {
  radius <- sqrt(qchisq(conf.level, df = 2))
  eigen_decomp <- eigen(cov)
  angle <- atan2(eigen_decomp$vectors[2, 1], eigen_decomp$vectors[1, 1])
  a <- radius * sqrt(eigen_decomp$values[1])
  b <- radius * sqrt(eigen_decomp$values[2])
  list(mean = mean, angle = angle, a = a, b = b)
}

# Function to determine overlap of two ellipses
ellipses_overlap <- function(ellipse1, ellipse2) {
  # Calculate the Euclidean distance between the centers of the ellipses
  distance <- sqrt(sum((ellipse1$mean - ellipse2$mean)^2))
  critical_distance <- ellipse1$a + ellipse2$a
  return(distance < critical_distance)
}

# Function to calculate cluster resolution
calculate_cluster_resolution <- function(data1, data2, initial_conf = 0.75) {
  conf.level <- initial_conf
  overlap <- TRUE
  
  while (overlap) {
    if (conf.level <= 0 || conf.level >= 1) {
      break
    }
    ellipse1 <- confidence_ellipse(colMeans(data1), cov(data1), conf.level)
    ellipse2 <- confidence_ellipse(colMeans(data2), cov(data2), conf.level)
    overlap <- ellipses_overlap(ellipse1, ellipse2)
    if (is.na(overlap)) {
      break
    }
    if (overlap) {
      conf.level <- conf.level - 0.01
    } else {
      conf.level <- conf.level + 0.01
    }
  }
  
  return(conf.level)
}

# Function to perform ANOVA and rank variables
rank_variables_anova <- function(data, group) {
  anova_results <- apply(data, 2, function(x) anova(lm(x ~ group))$`Pr(>F)`[1])
  ranked_vars <- order(anova_results)
  return(ranked_vars)
}

# With rank variables from highest to lowest of their calculated mean and std., variables here already occur in >1 sample
rank_variables_high_mean_std <- function(data) {
  temp1 <- data[, -c(1,2,3,5)] %>% column_to_rownames(., var="Sample_name")
  temp2 <- t(temp1)
  colnames(temp2) <- rownames(temp1)
  rownames(temp2) <- colnames(temp1)
  return(as.numeric((as.data.frame(temp2) %>% 
                       rownames_to_column(., var = "Feature") %>%
                       ungroup() %>%
                       rowwise() %>%
                       mutate(mean_area = mean(c_across(2:ncol(.)), na.rm = TRUE),
                              sd_area = sd(c_across(2:ncol(.)), na.rm = TRUE)) %>%
                       ungroup() %>% 
                       relocate(mean_area, sd_area, .before = 1) %>%
                       arrange(desc(mean_area), desc(sd_area)))$Feature))
         
}

# Function to perform PCA and calculate cluster resolution for multiple groups
variable_selection <- function(data, group, max_vars = 10) {
  # ranked_vars <- rank_variables_anova(data, group)
  ranked_vars <-  rank_variables_high_mean_std(data)
  selected_vars <- c()
  max_resolution <- 0
  resolutions <- c()
  
  for (i in 1:max_vars) {
    selected_vars <- c(selected_vars, ranked_vars[i])
    if (length(selected_vars) >= 2) {  # Ensure at least two variables are selected
      pca_model <- prcomp(data[, as.character(selected_vars)], center = TRUE, scale. = TRUE)
      scores <- pca_model$x
      
      group_levels <- levels(group)
      pair_resolutions <- c()
      
      # Calculate cluster resolution for each pair of groups
      for (g1 in 1:(length(group_levels) - 1)) {
        for (g2 in (g1 + 1):length(group_levels)) {
          data1 <- scores[group == group_levels[g1], 1:2]
          data2 <- scores[group == group_levels[g2], 1:2]
          resolution <- calculate_cluster_resolution(data1, data2)
          pair_resolutions <- c(pair_resolutions, resolution)
        }
      }
      
      avg_resolution <- mean(pair_resolutions, na.rm = TRUE)
      resolutions <- c(resolutions, avg_resolution)
    }
  }
  
  return(list(selected_vars = selected_vars, resolutions = resolutions))
}

# ----------------------------------------------------------------------------------------------
input1 <- percentage_normalized_all # %>% filter(supplier %notin% c("Miscellanous", "unknown"))
input2 <- input1[, 6:ncol(input1)]
group <- factor(input1$gas_station)

# Perform variable selection
max_vars <- ncol(input2)
result <- variable_selection(input2, group, max_vars = max_vars)
print(result)

# ----------------------------------------------------------------------------------------------
# Plot resolutions against number of variables
resolutions_df <- data.frame(
  num_vars = seq_along(result$resolutions),
  resolution = result$resolutions
)

ggplot(resolutions_df, aes(x = num_vars, y = resolution)) +
  geom_line() +
  geom_point() +
  labs(title = "Impact of Each Variable on Cluster Resolution",
       x = "Number of Variables Added",
       y = "Cluster Resolution") +
  theme_classic(base_size = 18) +
  scale_x_continuous(limits = c(1, max_vars), breaks = seq(from = 0, to = max_vars, by = 25)) +
  scale_y_continuous(limits = c(0, 1), breaks = seq(from = 0, 
                                                    to = 1, 
                                                    by = 0.1)) +
  theme(plot.title = element_text(hjust = 0.5),
        # axis.text.x = element_text(angle = 90),
        panel.grid.minor.x = element_blank(),
        panel.grid.minor.y = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_blank()
  )
``` 


# Multiple Welch t-tests with p-value correction for multiple testing

```{r, echo = TRUE, message = FALSE, warning = FALSE}
# Histogram
hist(as.numeric(unlist(input[which(input$supplier == "Shell"), 13])), col='steelblue', main='')
hist(as.numeric(unlist(input[which(input$supplier == "Cenovus"), 13])), col='steelblue', main='')

# Q-Q plots aka. Normal Probability plots
stats::qqnorm(as.numeric(unlist(input[which(input$supplier == "Shell"), 13])), main='')
stats::qqline(as.numeric(unlist(input[which(input$supplier == "Shell"), 13])))

stats::qqnorm(as.numeric(unlist(input[which(input$supplier == "Cenovus"), 13])), main='')
stats::qqline(as.numeric(unlist(input[which(input$supplier == "Cenovus"), 13])))
```

### Levene’s test-non-normally distributed data & Fligner-Killeen test
```{r, echo = FALSE, message = FALSE, warning = FALSE}
library(car)
# Here is an example case of a significant compound taken from  Welch's t-test(for unequal variances) of suppliers
data <- data.frame(group = factor(c(rep("group1", 
                                        length(as.numeric(unlist(input[which(input$gas_station == "Station_3"), 13])))), 
                                    rep("group2", 
                                        length(as.numeric(unlist(input[which(input$gas_station == "Station_10"), 13])))))),
                   values = c(as.numeric(unlist(input[which(input$gas_station == "Station_3"), 13])), 
                              as.numeric(unlist(input[which(input$gas_station == "Station_10"), 13]))))
                   
# Separate the groups
group1 <- data$values[data$group == "group1"]
group2 <- data$values[data$group == "group2"]

# Check normality for both groups
# Q-Q plots
qqnorm(group1, main = "Q-Q Plot for Group 1")
qqline(group1, col = "red")

qqnorm(group2, main = "Q-Q Plot for Group 2")
qqline(group2, col = "red")

# Shapiro-Wilk test
shapiro.test(group1)
shapiro.test(group2)

# Check variance homogeneity using Levene's test
library(car)
leveneTest(values ~ group, data = data) # A p-value greater than 0.05 indicates that the variances are equal (homoscedasticity). If < 0.05 -> use Welch's t-test

# Identify outliers
outlierTest(lm(differences ~ 1)) 
# (rstudent): Residuals significantly different from 0 (typically greater than 2 or less than -2) suggest potential outliers.
# (unadjusted p-value): A small p-value (typically < 0.05) indicates that the observation is a potential outlier.
# (Bonferroni p) : A small Bonferroni p-value (typically < 0.05) indicates a strong evidence that the observation is an outlier
```

###  Welch t-tests 
(Update 9th July 2024): Welch t-test is more appropriate than Wilcoxon test. 
```{r, echo = FALSE, message = FALSE, warning = FALSE}
input <- percentage_normalized[[4]] %>%
  filter(supplier %notin% c("Miscellanous", "unknown")) %>%
  column_to_rownames(., var = "Sample_name")

sig_comp <- list()
pair_test_results <- list()
j <- 1

df <- data.frame(Feature=character(), comparison_pair=character(), pval=integer())

for (c in 6:ncol(input)) {      
  # looping through the combinations of product categories 
  for (col in 1:ncol(utils::combn(unique(input$gas_station), 2))) {  # "sampling_season", "Octane_rating", "gas_station"
    # extract the combinations of product category pairs
    p_1 <- utils::combn(unique(input$gas_station), 2)[1,col]
    p_2 <- utils::combn(unique(input$gas_station), 2)[2,col]
    
    # calculating the p-value between each gas station pair 
    pval <- t.test(as.numeric(unlist(input[which(input$gas_station == p_1), c])), 
                   as.numeric(unlist(input[which(input$gas_station == p_2), c])))$p.value
    # assigning row information
    df[nrow(df) + 1,] <- c(colnames(input)[c], 
                           paste0(p_1, " & ", p_2), 
                           pval)
  }
}

pvaluecorrect <- c("holm", "hochberg", "hommel", "BH", "BY")
for (m in pvaluecorrect) {
  df$adjusted_pvalue <- stats::p.adjust(df$pval, method = m)
  print(df %>%
          filter(., adjusted_pvalue < 0.05) %>%
          arrange(adjusted_pvalue))
  
  sig_comp[[j]] <- df %>%
          filter(., adjusted_pvalue < 0.05) %>%
          arrange(adjusted_pvalue)
  
  pair_test_results[[j]] <- df
  j <- j + 1
}

rt1 <- c()
rt2 <- c()
major <- c()
minor <- c()
chem_grp <- c()
compound_name <- c()
for (row in 1:nrow(sig_comp[[1]])) {
  # print(row)
  rt1 <- c(rt1, metadata_na_remove[which(metadata_na_remove$Feature == as.numeric(sig_comp[[1]][row,]$Feature)),]$RT1)
  rt2 <- c(rt2,metadata_na_remove[which(metadata_na_remove$Feature == as.numeric(sig_comp[[1]][row,]$Feature)),]$RT2)
  major <- c(major, metadata_na_remove[which(metadata_na_remove$Feature == as.numeric(sig_comp[[1]][row,]$Feature)),]$Ion1)
  minor <- c(minor, metadata_na_remove[which(metadata_na_remove$Feature == as.numeric(sig_comp[[1]][row,]$Feature)),]$Ion2)
  chem_grp <- c(chem_grp, metadata_na_remove[which(metadata_na_remove$Feature == as.numeric(sig_comp[[1]][row,]$Feature)),]$Chemical_group)
}

sig_comp[[1]]$RT1 <- rt1
sig_comp[[1]]$RT2 <- rt2
sig_comp[[1]]$Ion1 <- major
sig_comp[[1]]$Ion2 <- minor
sig_comp[[1]]$Chemical_group <- chem_grp

## Get compound name 
compound_name <- c()
for (row in 1:nrow(sig_comp[[1]])) {
  idx <- which(abs(ASTM$RT1 - sig_comp[[1]][row,]$RT1) <= 0.1 &
                 abs(ASTM$RT2 - sig_comp[[1]][row,]$RT2) <= 0.1 &
                 abs(ASTM$Ion1 - sig_comp[[1]][row,]$Ion1) <= 0.1 &
                 abs(ASTM$Ion2 - sig_comp[[1]][row,]$Ion2) <= 0.1)
  # print(paste0(row, "_", idx))
  if (identical(idx, integer(0))) {
    compound_name <- c(compound_name, "unknown")
  }
  compound_name <- c(compound_name, ASTM[idx,]$Compound)
}
sig_comp[[1]]$compound_name <- compound_name

# write_xlsx(sig_comp[[1]], path = paste0("Welchttest_", "top25", "_", "0.001_TSN_", format(Sys.time(), "%d-%m-%Y"), ".xlsx"))
```

# Clustering analyses

## PCA

(Update 15 April 2024:) When using either Octane_rating OR sampling_season, there is no clustering whatsoever between seasons OR Octane rate

!!! After removing unique cols
*** With global minimum imputation:

!! Tried top 150 compounds with highest cumulative peak area => still no clustering on both sampling seasons and octane rating.

!! Tried top 150 compounds with highest variance 

(Update 29th April:) 
**DATA COMPRESSION OR NOT??**

If I **compress all samples into a grouping variables**, such as Octane_rating or sampling_season, I can clearly see the differentiation between these grouping variables. 

**For gas station, ** all 3 imputation techniques all resulted in low Dim1 and Dim2. However, with Zero and Global Min, there seems to be a grouping of gas station no. 2,8,3 (group 1); no. 1, 5 (group 2), no. 10, 4, 9, 7, 6 (group 3).

***If I keep the samples separated*** , then I tried log normalization with 3 imputation techniques ==> Zero imputation will resulted in -Inf after Log-normalization so we can only do Global min and LOD. However, both global min and LOD does nto result in any clear grouping/clustering between "sampling_season", "Octane_rating", "gas_station".

**LOG NORMALIZATION VERSUS. PERCENTAGE-BASED NORMALIZATION**
I also tried remove the top 100 compounds that have really high mean and low variance across sample and perform zero//global min// LOD imputation on them and then tried Log-normalization ==> still no clustering between gas station!!

Also, I tried to run PCA with un-normalized data (after imputation) with 3 imputation methods but still no clustering of gas stations across all 3 imputation methods.

(Update 22nd May 2024:) 
 - Clustering again with 'optimized' alignment windows -> No cluster of gas station
 - Use only target compounds -> Still No cluster of gas station either with zero or LOD imputation coupled with TSN or Log normalization.

```{r, echo = FALSE, message = FALSE, warning = FALSE}
t_test_res <- read_xlsx(path = "C:/Users/huyng/OneDrive - Toronto Metropolitan University/Arson manuscript/Arson project/Rproject/Arson/Welch t test/Welchttest_top200_0.001_TSN_19-07-2024.xlsx")
t_test_res <- t_test_res %>% 
  filter(compound_name %notin% "unknown") %>%
  mutate(pca_var = paste0(compound_name, " (RT1: ", round(RT1, 4), ", RT2: ", round(RT2, 4), ")"))

name_list <- list()
i <- 1
for (name in unique(t_test_res$Feature)) {
  name_list[[name]] <- unique(t_test_res[which(t_test_res$Feature == name),]$pca_var)
}

pca_input <- percentage_normalized[[4]] %>% 
  select(c("gas_station", "Sample_name", unique(t_test_res$Feature))) %>%
  filter(gas_station %in% c("Station 3", "Station 4", "Station 6", "Station 7")) %>%
  column_to_rownames(., var = "Sample_name")

colnames(pca_input) <- c("gas_station", unlist(name_list))
------------------------------------------------------------------------------------------------------------------
plot_list <- list()
for (i in 1:length(percentage_normalized)) {
  pca_input <-
    percentage_normalized[[i]] %>% filter(supplier %notin% c("Miscellanous", "unknown"))
  
  res.pca <- FactoMineR::PCA(
    pca_input[, 6:ncol(pca_input)],
    scale.unit = FALSE,
    graph = FALSE)
  
  # Scree plot
  # fviz_screeplot(res.pca, ncp=10)
  
  # Biplot
  plot_list[[i]] <- factoextra::fviz_pca_biplot(res.pca,  
                                                geom = "text",
                                                label = "ind",
                                                repel = TRUE,
                                                labelsize = 5, 
                                                habillage = factor(pca_input$gas_station), # "sampling_season", "Octane_rating", "gas_station", "Sample_name", "supplier"
                                                # palette = "ucscgb",
                                                addEllipses = TRUE,
                                                ellipse.level = 0.95,
                                                # xlim = c(-0.2, 0.2),
                                                # ylim = c(-0.009, 0.009),
                                                ggtheme = ggplot2::theme_minimal(base_size = 20),
                                                title = paste0("Top ", ncol(pca_input[, 6:ncol(pca_input)]), " features")
  ) + 
    # if has error "Too few points to calculate an ellipse"
    # ggforce::geom_mark_ellipse(aes(fill = Groups,
    #                                color = Groups),
    #                            label.buffer = unit(20, 'mm')) +
    theme(legend.position = 'bottom',
          panel.spacing = unit(0, "lines"))
}

grid.arrange(plot_list[[1]], 
             plot_list[[2]], 
             plot_list[[3]],
             plot_list[[4]], ncol=2, nrow = 2)

```

## NMDS 
**References:** 
https://eddatascienceees.github.io/tutorial-rayrr13/
https://jonlefcheck.net/2012/10/24/nmds-tutorial-in-r/

```{r echo=FALSE, warning=FALSE, message=FALSE}
data <- percentage_normalized 

# Calculate the dissimilarity matrix using Bray-Curtis distance
dissimilarity_matrix <- vegdist(data %>% select(6:ncol(data)), method = "bray", na.rm = TRUE)

# Perform NMDS
nmds_result <- metaMDS(dissimilarity_matrix, k = 2, trymax = 100)

# Extract NMDS scores
nmds_scores <- as.data.frame(scores(nmds_result))

# Add metadata (Product_Name, Source, Day) to the NMDS scores
nmds_scores <- cbind(nmds_scores, data %>% select(supplier, sampling_season, Octane_rating, gas_station, Sample_name))

# Define a vector of shapes
shapes <- c(0:16) #, 21:24, 25:32, 33:40, 41:48, 49:56, 57:63)

# Generate a discrete color palette with 61 colors
# palette <- colorspace::qualitative_hcl(61, palette = "Dark 3")

# Plot the NMDS results using ggplot2
ggplot(nmds_scores, aes(x = NMDS1, y = NMDS2)) +
  geom_point(aes(
    color = sampling_season,
    shape = sampling_season), size = 3) +
  labs(title = "NMDS",
       x = "NMDS1", y = "NMDS2") +
  theme_minimal() +
  theme(legend.position = "right") +
  # scale_color_manual(name = "Source", values = palette) +
  scale_shape_manual(name = "Source", values = shapes)

# Report Stress values
stressplot(nmds_result)

# PERMANOVA results
## Reference: 
## https://nathanielwoodward.com/posts/a-cool-thing-called-permanova/
## https://onlinelibrary.wiley.com/doi/full/10.1002/9781118445112.stat07841

```

## HCA

```{r, echo=FALSE, warning = FALSE, message=FALSE}
hc_df <- percentage_normalized[, -c(1:5)]

## Dissimilarity Indices Calculated by vegan::vegdist()
hca_samp <- stats::hclust(vegan::vegdist(hc_df,
                                         method = "robust.aitchison")) # Since our data is continous -> canberra // manhattan // robust.aitchison

plot(hca_samp,
     labels = percentage_normalized$supplier,
     hang = -1,
     main = "", cex = 1.25)
```    

## t-SNE

```{r, echo=FALSE, warning = FALSE, message=FALSE}
# REFERENCES VISUALIZATION: 
# https://plotly.com/r/t-sne-and-umap-projections/
# https://distill.pub/2016/misread-tsne/

library(tsne)
library(plotly)

features <- subset(percentage_normalized, select = 5:ncol(percentage_normalized))

tsne <- tsne(features,
             initial_dims = 3, 
             k = 3, 
             perplexity = 30, # Hyperparameter: perplexity (optimal number of neighbors) < number of samples
             max_iter = 5000
             )

pdb <- cbind(data.frame(tsne), percentage_normalized$Octane_rating)
options(warn = -1)
tsne_plot <- plot_ly(data = pdb ,x =  ~X1, y = ~X2, z = ~X3, 
               color = ~percentage_normalized$Octane_rating) %>% 
  add_markers(size = 8) %>%
  layout( 
    xaxis = list(
      zerolinecolor = "#ffff",
      zerolinewidth = 2,
      gridcolor='#ffff'), 
    yaxis = list(
      zerolinecolor = "#ffff",
      zerolinewidth = 2,
      gridcolor='#ffff'),
    scene =list(bgcolor = "#e5ecf6"))

tsne_plot
```

## UMAP clustering 

```{r, echo=FALSE, warning = FALSE, message=FALSE}
input <- percentage_normalized

features <- input[, -c(1:4)]

umap <- umap(features, n_components = 3,
             alpha = 0.00001, gamma = 0.00001,
             metric = "pearson2") # euclidean, manhattan, cosine, pearson, pearson2

layout <- cbind(data.frame(umap[["layout"]]), input$gas_station)
umap_plot <- plot_ly(layout, x = ~X1, y = ~X2, z = ~X3, 
                color = ~input$gas_station) %>% 
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'x-axis'),
                      yaxis = list(title = 'y-axis'),
                      zaxis = list(title = 'z-axis')))
umap_plot
```


### SIMCA
```{r, echo = FALSE, message = FALSE, warning = FALSE}
library(chemometrics)
library(pls)
library(caret)

test <- percentage_normalized %>% filter(supplier %notin% "unknown")
X <- test[, -c(1:5)]  # feature matrix
Y <- factor(test$supplier, levels = unique(test$supplier))  # class labels

set.seed(123)  # for reproducibility
trainIndex <- createDataPartition(Y, p = 0.8, list = FALSE)
X_train <- X[trainIndex, ]
Y_train <- Y[trainIndex]
X_test <- X[-trainIndex, ]
Y_test <- Y[-trainIndex]

# Function to fit PCA model for a given class
fit_pca_model <- function(class_data, ncomp) {
  pca_model <- prcomp(class_data, center = FALSE, scale. = FALSE)
  pca_model$x <- pca_model$x[, 1:ncomp]  # keep only ncomp components
  return(pca_model)
}

# Fit PCA models for each class
class_levels <- levels(Y_train)
pca_models <- list()

for (class in class_levels) {
  class_data <- X_train[Y_train == class, ]
  pca_models[[class]] <- fit_pca_model(class_data, ncomp = 2)  # example with 2 components
}

# Function to calculate residuals and scores for a sample
calculate_residuals_scores <- function(sample, pca_model) {
  scores <- as.matrix(sample) %*% pca_model$rotation
  residuals <- sample - (scores %*% t(pca_model$rotation))
  return(list(scores = scores, residuals = residuals))
}

# Apply the function to test data
results <- list()

for (i in 1:nrow(X_test)) {
  sample <- X_test[i, ]
  sample_results <- list()
  for (class in class_levels) {
    res <- calculate_residuals_scores(sample, pca_models[[class]])
    sample_results[[class]] <- res
  }
  results[[i]] <- sample_results
}

# Function to calculate Q-residuals and T² for a sample
calculate_criteria <- function(residuals, scores, pca_model) {
  Q_residuals <- sum(residuals^2)
  T2 <- sum((scores^2) / apply(pca_model$x, 2, var))
  return(list(Q_residuals = Q_residuals, T2 = T2))
}

# Calculate criteria for each sample and each class
criteria <- list()

for (i in 1:length(results)) {
  sample_criteria <- list()
  for (class in class_levels) {
    res <- results[[i]][[class]]
    crit <- calculate_criteria(res$residuals, res$scores, pca_models[[class]])
    sample_criteria[[class]] <- crit
  }
  criteria[[i]] <- sample_criteria
}

# Simple classification rule based on threshold values (adjust thresholds as needed)
classify_sample <- function(criteria, Q_threshold, T2_threshold) {
  for (class in names(criteria)) {
    if (criteria[[class]]$Q_residuals < Q_threshold && criteria[[class]]$T2 < T2_threshold) {
      return(class)
    }
  }
  return("unknown")
}

# Apply classification to each sample
predictions <- sapply(criteria, classify_sample, Q_threshold = 10, T2_threshold = 5)

# Compare predictions with true labels
confusionMatrix(factor(predictions, levels = class_levels), Y_test)

```






















# **Using only target compounds**

```{r, echo = FALSE, message = FALSE, warning = FALSE}
dflist <- list()
i <- 1
for (j in 1:nrow(target_comp)) {
  # Catch all peaks in dataframe that falling into the window with target compounds as center of the window
   idx1 <- which((df_step2$Ion1 <= (target_comp[j,]$Ion1 + 0.1) & df_step2$Ion1 >= (target_comp[j,]$Ion1 - 0.1) & 
                   df_step2$Ion2 <= (target_comp[j,]$Ion2 + 0.1) & df_step2$Ion2 >= (target_comp[j,]$Ion2 - 0.1)) |
                  
                  (df_step2$Ion1 <= (target_comp[j,]$Ion2 + 0.1) & df_step2$Ion1 >= (target_comp[j,]$Ion2 - 0.1) &
                     df_step2$Ion2 <= (target_comp[j,]$Ion1 + 0.1) & df_step2$Ion2 >= (target_comp[j,]$Ion1 - 0.1)))
  
  temp <- df_step2[idx1,]
  idx2 <- which(temp$RT1 <= (target_comp[j,]$RT1 + 0.4) & 
                  temp$RT1 >= (target_comp[j,]$RT1 - 0.4) &
                  temp$RT2 <= (target_comp[j,]$RT2 + 0.16) & 
                  temp$RT2 >= (target_comp[j,]$RT2 - 0.16))
  
  dflist[[i]] <- temp[idx2,] %>% mutate(Feature = paste0("Compound_", i, "."))
  i <- i + 1
}
    
test <- bind_rows(dflist)
filter_alignment <- comp_filter(test)

shared_comp_alignment <- test[filter_alignment[[1]],]
```


# Overlay Scatter plot as Visual confirmation of appropriate RT windows by checking overlapping of RT1 and RT2 of aligned compounds and target compounds
```{r, echo = FALSE, message = FALSE, warning = FALSE}
plotlist <- list()
i <- 1
for (j in 1:nrow(target_comp)) {
  idx1 <- which((alignment$Ion1 <= (target_comp[j,]$Ion1 + 0.1) & alignment$Ion1 >= (target_comp[j,]$Ion1 - 0.1)) | 
                  (alignment$Ion1 <= (target_comp[j,]$Ion2 + 0.1) & alignment$Ion1 >= (target_comp[j,]$Ion2 - 0.1)))
  
  temp <- alignment[idx1,]
  idx2 <- which(temp$RT1 <= (target_comp[j,]$RT1 + 0.4) & 
                  temp$RT1 >= (target_comp[j,]$RT1 - 0.4) &
                  temp$RT2 <= (target_comp[j,]$RT2 + 0.16) & 
                  temp$RT2 >= (target_comp[j,]$RT2 - 0.16))
  plotlist[[i]] <- temp[idx2,]
  i <- i + 1
}

plotdf <- bind_rows(plotlist)

plotly::ggplotly(ggplot() +
                   geom_point(data = plotdf, aes(x = RT1, y = RT2, colour = Feature), pch = 1, size = 0.5) +
                   geom_point(data = target_comp, pch = 4, size = 2, colour = "red",
                              aes(x=RT1, y= RT2, label = Compound)) + 
                   xlim(5, 40))
```

### Catch by compound name
```{r, echo = FALSE, message = FALSE, warning = FALSE}
step3 <- df_step1.2 %>%
  filter(Area > 300000) %>%
  filter(!is.na(Compound))

unique_comp <- c()
# all_unique_compounds_idx <- c()

for (comp_grp in unique(step3$Compound)) {
  idx <- which(grepl(comp_grp, step3$Compound, fixed = TRUE))
  
  if (length(unique(step3[idx,]$Sample_name)) < 2) {
    print(comp_grp)
    unique_comp <- c(unique_comp, comp_grp)
    next
  }
}

shared_comp_alignment <- step3 %>% filter(Compound %notin% unique_comp)
```

























## ANOVA 
(Update 15 April 2024:) 
*** With Zero imputation 
1. There is no difference between sampling seasons
                Df    Sum Sq   Mean Sq F value Pr(>F)
sampling_season  2 2.370e-31 1.184e-31   0.603   0.55
Residuals       68 1.335e-29 1.963e-31   

2. There is no difference between Octane rating
              Df    Sum Sq   Mean Sq F value Pr(>F)
Octane_rating  3 1.800e-32 6.160e-33    0.03  0.993
Residuals     67 1.356e-29 2.025e-31 

*** With global minimum imputation
1. There is no difference between sampling seasons
                Df    Sum Sq   Mean Sq F value Pr(>F)
sampling_season  2 6.710e-27 3.354e-27   1.222  0.301
Residuals       68 1.866e-25 2.744e-27  

2. There is no difference between Octane rating
              Df   Sum Sq   Mean Sq F value Pr(>F)
Octane_rating  3 2.28e-27 7.603e-28   0.267  0.849
Residuals     67 1.91e-25 2.851e-27

==> WHAT's NEXT?: Try to remove compound that appear in only 1 sample and run ANOVA//PCA again

!!! After removing unique cols
*** With Zero imputation
1. There is no difference between sampling seasons
                Df    Sum Sq   Mean Sq F value Pr(>F)
sampling_season  2 8.280e-31 4.141e-31   1.354  0.265
Residuals       68 2.079e-29 3.058e-31 

2. There is no difference between Octane rating
              Df    Sum Sq   Mean Sq F value Pr(>F)
Octane_rating  3 4.420e-31 1.473e-31   0.466  0.707
Residuals     67 2.118e-29 3.161e-31 

*** With global minimum imputation 
1. There is no difference between sampling seasons
                Df    Sum Sq   Mean Sq F value  Pr(>F)   
sampling_season  2 2.539e-26 1.269e-26    6.71 0.00219 **
Residuals       68 1.286e-25 1.892e-27                   
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 

2. There is no difference between Octane rating
              Df    Sum Sq   Mean Sq F value Pr(>F)
Octane_rating  3 3.250e-27 1.085e-27   0.482  0.696
Residuals     67 1.508e-25 2.250e-27

(Update 22nd April 2024:) There is no difference between gas stations
            Df    Sum Sq   Mean Sq F value Pr(>F)
gas_station  9 4.311e-30 4.790e-31   0.926  0.509
Residuals   61 3.155e-29 5.171e-31 

```{r, echo = FALSE, message = FALSE, warning = FALSE}
summary(aov(as.formula(paste(paste(setdiff(names(comp_normalized_rt10.1 %>%
                                             select(-c("Octane_rating", "sampling_season"))), "gas_station"), collapse = "+"), " ~ gas_station")), data = comp_normalized_rt10.1 %>%
                                             select(-c("Octane_rating", "sampling_season"))))
```

```{r, echo = FALSE, message = FALSE, warning = FALSE}
## SELECT TOP 100 COMPOUNDS THAT HAVE HIGHEST CUMULATIVE PEAK AREA ACROSS ALL SAMPLES ---------------
# Compute the sum of values of each column
column_sums <- colMeans(df_step3[,4:ncol(df_step3)])

# Order the columns based on their sum values
# Select the top 100 columns with the highest sum value
top_100_cum_sum <- names(column_sums)[order(column_sums, decreasing = TRUE)[1:100]]

# Create a new dataframe with only the top 100 columns
df_step3 <- df_step3[, c("Octane_rating", "samp_event", "gas_station", top_100_cum_sum)]

## SELECT TOP 150 COMPOUNDS THAT HAVE HIGHEST Variance of ACROSS ALL SAMPLES ------------
# Compute variance of values for each column
variances <- apply(df_step3[,3:ncol(df_step3)], 2, var)

# Sort variances in descending order and get the indices of the top 100 columns
top_100_var <- order(variances, decreasing = TRUE)[1:100]

# Select the top 100 columns with highest variance values
df_step3 <- df_step3[, c(1, 2, top_100_var)]

```
